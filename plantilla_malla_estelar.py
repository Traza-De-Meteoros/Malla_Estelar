# -*- coding: utf-8 -*-
"""Plantilla Malla Estelar

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uenDP7Sdyyf876qUvSUZeJNwDB_Whbsj
"""

import math
import numpy as np
import pandas as pd
from Estelares import transform_from_json_to_list
from Estelares import PuntosImagen as Puntos_Imagen
#M+numero de estacion+numero de camara +DD/Mes/AAAA  HH:MM:SS
#Estas son las ecuaciones 5.2(pag 37)
def calcularXestandar(Azimut,Altitud,AzimutObservador,AltitudObservador):

  x = (-1 * math.sin(Azimut-AzimutObservador) * math.cos(Altitud)) / ((math.cos(Azimut -AzimutObservador) * math.cos(Altitud) * math.cos(AltitudObservador)) + (math.sin(Altitud) * math.sin(AltitudObservador)))

  return x

def calcularYestandar(Azimut,Altitud,AzimutObservador,AltitudObservador):

  y = ((-1 * math.cos(Azimut-AzimutObservador) * math.cos(Altitud) * math.sin(AltitudObservador)) + (math.sin(Altitud) * math.cos(AltitudObservador))) / ((math.cos(Azimut-AzimutObservador) * math.cos(Altitud) * math.cos(AltitudObservador)) + (math.sin(Altitud)*math.sin(AltitudObservador)))

  return  y


PuntosImagen:list=transform_from_json_to_list("src/PuntosImagen.json")


#Esta parte son las ecuaciones 5.1

A = 0
D = 0

#Se obtiene la A y D haciendo la suma de todas las ascenciones y declinaciones
for punto in PuntosImagen:
  A = A + math.radians(punto.ascencion)#Primero usa radianes
  D = D + math.radians(punto.declinacion)

A = (1/len(PuntosImagen)) * A
D = (1/len(PuntosImagen)) * D
print('A:' + str(A))
print('D:' + str(D))
print('A:' +str(math.degrees(A)))
print('D:'+ str(math.degrees(D)))



Punto_AD= Puntos_Imagen("Punto A,D", math.degrees(A),math.degrees(D),0,0)#luego grados?

#Esta parte es para generar un archivo excell con la informacion de las estreellas de referencia
PuntosImagen.append(Punto_AD)
PuntosImagenDF = pd.DataFrame(PuntosImagen)
PuntosImagenDF.to_excel("Puntos.xlsx")

#Se calcula las coordenadas estandar para poder calcular los parametros 5.3
for punto in PuntosImagen:
  punto.xi = calcularXestandar(math.radians(punto.ascencion),math.radians(punto.declinacion),A,D)
  #print(punto['xi'])
  punto.psi = calcularYestandar(math.radians(punto.ascencion),math.radians(punto.declinacion),A,D)
  #print(punto['psi'])
  #print("\n")
  #PuntosImagen

#Parametros de la imagen (5.3)

ParamA = 0
ParamB = 0
ParamC = 0
ParamD = 0
ParamE = 0
ParamF = 0
ParamG = 0
for punto in PuntosImagen:
  ParamA = ParamA + punto.x
  ParamB = ParamB + punto.y
  ParamC = ParamC + punto.xi
  ParamD = ParamD + punto.psi
  ParamE = ParamE + (math.pow(punto.x,2) + math.pow(punto.y,2))
  ParamF = ParamF + ((punto.xi * punto.x)+(punto.psi*punto.y))
  ParamG = ParamG + ((punto.xi * punto.y)-(punto.psi*punto.x))
print('ParamA: ' + str(ParamA))
print('ParamB: ' + str(ParamB))
print('ParamC: ' + str(ParamC))
print('ParamD: ' + str(ParamD))
print('ParamE: ' + str(ParamE))
print('ParamF: ' + str(ParamF))
print('ParamG: ' + str(ParamG))

#Parámetros u (5.4)
u1 = (len(PuntosImagen)*ParamF) - (ParamA*ParamC) - (ParamB*ParamD)
u2 = (len(PuntosImagen)*ParamG) - (ParamB*ParamC) + (ParamA*ParamD)
u3 = -(ParamA*ParamF) - (ParamB*ParamG) + (ParamE*ParamC)
u4 = -(ParamB*ParamF) + (ParamA*ParamG) + (ParamE*ParamD)
u5divisor = (len(PuntosImagen)*ParamE) - (math.pow(ParamA,2)+math.pow(ParamB,2))
u5 = 1/(math.pow(u5divisor,1))
print('U1: ' + str(u1))
print('U2: ' + str(u2))
print('U3: ' + str(u3))
print('U4: ' + str(u4))
print('U5: ' + str(u5))
print('U5div: ' + str(u5divisor))

#Ecuaciones 5.6
def calcularalpha(u1,u2,u3,u4,u5,X,Y,A,D):

  #xi = (u5) * ((u1*X)+(u2*Y)+u3)
  #psi = (u5) * ((-1*u2*X)+(u1*Y)+(u4))
  #Se calcula las coordenadas estandar a partir de las ecaciones 5.5
  xi = calcularxi(u1,u2,u3,u5,X,Y)
  psi = calcularpsi(u1,u2,u4,u5,X,Y)
  #Ecuacion 5.6 para ascensión
  alpha = A + math.atan((-xi)/(math.cos(D)-(psi*math.sin(D))))
  return alpha

def calculardelta(u1,u2,u3,u4,u5,X,Y,A,D):
  #xi = (u5) * ((u1*X)+(u2*Y)+u3)
  #psi = (u5) * ((-1*u2*X)+(u1*Y)+(u4))
  xi = calcularxi(u1,u2,u3,u5,X,Y)
  psi = calcularpsi(u1,u2,u4,u5,X,Y)
  deltadivisor = math.pow(psi,2) + math.pow(xi,2) +1
  deltadividendo = (psi*math.cos(D)) + math.sin(D)
   #Ecuacion 5.6 para declinacion
  delta = math.asin((deltadividendo)/(math.sqrt(deltadivisor)))

  return  delta
#Se calcula las coordenadas estandar a partir de las ecaciones 5.5
def calcularxi(u1,u2,u3,u5,X,Y):
  return (u5) * ((u1*X)+(u2*Y)+u3)
def calcularpsi(u1,u2,u4,u5,X,Y):
  return (u5) * ((-1*u2*X)+(u1*Y)+(u4))


EstRef =[{

		"Nombre": "Alpheratz",
		"Ascension": 2.3443,
		"Declinacion": 29.0926,
		"X": 613,
		"Y": 334
	},
    {

		"Nombre": "Algenib",
		"Ascension": 3.5525,
		"Declinacion": 15.1861,
		"X": 323,
		"Y": 374
	},
    {

		"Nombre": "Markab",
		"Ascension": 346.4246,
		"Declinacion": 15.2080,
		"X": 327,
		"Y": 37
	},
    {

		"Nombre": "Funda",
		"Ascension": 345.9486,
		"Declinacion": 28.0871,
		"X": 593,
		"Y": 43
	}

	]

#Se calcula las coordeandas estandar a partir de las coordenadas estelares ec 5.2
for estrella in EstRef:
  estrella['xi'] = calcularXestandar(math.radians(estrella['Ascension']),math.radians(estrella['Declinacion']),A,D)
  estrella['psi'] = calcularYestandar(math.radians(estrella['Ascension']),math.radians(estrella['Declinacion']),A,D)
#Para calcular error o diferencia entre las coordenadas estelares se calcula pero esta vez utilizando las ec 5.5
for estrella in EstRef:
	estrella['XI'] = calcularxi(u1,u2,u3,u5,estrella['X'],estrella['Y'])
	estrella['PSI'] = calcularpsi(u1,u2,u4,u5,estrella['X'],estrella['Y'])

#Con las ecuaciones 5.5 se forma un sistema de ecuaciones para calcular las coordenadsa
#X,Y de Imagen teniendo parametros u y coordenadas estándar.
def calcularCoordenadasImagen(u1,u2,u3,u4,u5,psi,xi):
  Ca = (xi/u5)-u3
  Cb = (psi/u5)-u4
  A = np.array([[u1, u2], [-u2, u1]])
  b = np.array([Ca,Cb])
  return np.linalg.solve(A, b)

def coordenadaX(u1,u2,u3,u4,u5,psi,xi):
  coordenadasImagen = calcularCoordenadasImagen(u1,u2,u3,u4,u5,psi,xi)
  x = coordenadasImagen.item(0)
  return x

def coordenadaY(u1,u2,u3,u4,u5,psi,xi):
  coordenadasImagen = calcularCoordenadasImagen(u1,u2,u3,u4,u5,psi,xi)
  y = coordenadasImagen.item(1)
  return y

#Se calcula las coordenadas de imagen y el error para cada estrella
for estrella in EstRef:
  estrella['coordenadaX'] = round(coordenadaX(u1,u2,u3,u4,u5, estrella['psi'],estrella['xi']))
  estrella['coordenadaY'] = round(coordenadaY(u1,u2,u3,u4,u5,estrella['psi'],estrella['xi']))

  estrella['Error X'] = round(abs(((estrella['coordenadaX'] - estrella['X']))/abs(estrella['X']))*100,3)
  estrella['Error Y'] = round(abs(((estrella['coordenadaY'] - estrella['Y']))/abs(estrella['Y']))*100,3)
EstRef

#A partir las coordeandas de Imagen calculadas se calculan las coordenaas estandar
#para poder coomparar las coordenadas del cátalogo con las obtenidas a partir del software
for estrella in EstRef:
  estrella['Asc'] = round(math.degrees(calcularalpha(u1,u2,u3,u4,u5,estrella['coordenadaX'],estrella['coordenadaY'],A,D)),3)
  estrella['Dec'] = round(math.degrees(calculardelta(u1,u2,u3,u4,u5,estrella['coordenadaX'],estrella['coordenadaY'],A,D)),3)
  estrella['Error alpha'] = round(abs(((estrella['Asc'] - estrella['Ascension']))/abs(estrella['Ascension']))*100,3)
  estrella['Error delta'] = round(abs(((estrella['Dec'] - estrella['Declinacion']))/abs(estrella['Declinacion']))*100,3)

#Error de coordenadas estandar
for estrella in EstRef:
  estrella['Error estandar XI'] = round(abs(((estrella['XI'] - estrella['xi']))/abs(estrella['xi']))*100,3)
  estrella['Error estandar PSI'] = round(abs(((estrella['PSI'] - estrella['psi']))/abs(estrella['psi']))*100,3)
EstRef

import matplotlib.pyplot as plt
CalStars = pd.DataFrame(EstRef)
#Se ponde de fondo la imagen de observación
img = plt.imread("Prueba1.png")
f = plt.figure()
f.set_figwidth(10)
f.set_figheight(10)
#Se imprime dentro de la foto las estrellas.En este caso como el Eje Y possitivo es
#hacia abajo se realiza nuevamente la resta del ancho de la imagen a la coordenada Y obtenida
plt.scatter(CalStars['coordenadaX'], 519-CalStars['coordenadaY'],
           color='red', marker='.', linewidths=0,
           zorder=2)
#El primer scatter es para las coordenadas calculadas, y el segundo para la coordenadas que uno previamente ha medido.
plt.scatter(CalStars['X'], 519-CalStars['Y'],
           color='blue', marker='.', linewidths=0,
           zorder=2)
#Para poder imprimir el nombre de la estrella a lado
for star in CalStars.index:
  plt.text(CalStars['X'][star]+0.3,519-CalStars['Y'][star]+0.3,CalStars['Nombre'][star],fontsize=9, color='white')

plt.imshow(img)
plt.show()
CalStars.to_excel("Test estandar.xlsx") #Genera un excell con los resultados obtenidos

